---
layout: post
title: How to examine and optimise locking in MySQL
date: '2015-03-07T23:46:00.000-08:00'
author: Stephen Nancekivell
tags: 
modified_time: '2015-03-12T03:03:29.832-07:00'
blogger_id: tag:blogger.com,1999:blog-2519344180739427574.post-4951657510566346461
blogger_orig_url: http://blog.stephenn.com/2015/03/how-to-examine-and-optimise-locking-in.html
---

<div></div><div><br />Consider the following queries, each will lock the database in different ways. In this post Im going to show you how you see where each one is locking, and how to optimise it.</div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> update TabFoo set bla = ‘bla’ where id = 1;  <br /> update TabFoo set bla = ‘bla’ where foo = ‘bla';  <br /></code></pre><div><br /></div><div><b>To see the locks</b> in MySQL innodb, start a transaction run the query, then inspect the innodb status. Finally rollback or commit the transaction. We need to do this inside a transaction so the locks are held long enough for us to see them. If we don’t use a transaction, these locks will still&nbsp;be used, but they will happen very quickly.</div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> begin transaction;  <br /> update TabFoo set bla = ‘bla’ where id = 1;  <br /> show engine innodb status;  <br /> rollback;  <br /></code></pre><br /><div>In the innodb status, look for the section Transactions. Here we can see it has 1 row lock. Thats great and what you’d expect for a simple update by a primary key.</div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> ------------  <br /> TRANSACTIONS  <br /> ------------  <br /> Trx id counter 4830020  <br /> Purge done for trx's n:o &lt; 4830017 undo n:o &lt; 0 state: running but idle  <br /> History list length 472  <br /> LIST OF TRANSACTIONS FOR EACH SESSION:  <br /> ---TRANSACTION 0, not started  <br /> MySQL thread id 27, OS thread handle 0x1300ef000, query id 4320 localhost 127.0.0.1 root cleaning up  <br /> ---TRANSACTION 4830019, ACTIVE 3 sec  <br /> 2 lock struct(s), heap size 360, 1 row lock(s), undo log entries 1  <br /> MySQL thread id 28, OS thread handle 0x130133000, query id 4322 localhost 127.0.0.1 root init  <br /></code></pre><div><br /></div><div><b>Full table locking</b><br /><div style="-webkit-text-stroke-width: 0px; color: black; font-family: Times; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px;"><div style="margin: 0px;">In my test database table I&nbsp;only have 13 rows, and its locking them all. This query locks the whole table because it doesn’t know how many rows match the query, it could be all of them. This can been seen with “explain plan” of the query.</div></div></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> update TabFoo set bla = ‘bla’ where foo = ‘bla';  <br /> ---TRANSACTION 4830029, ACTIVE 4 sec  <br /> 2 lock struct(s), heap size 360, 13 row lock(s), undo log entries 2  <br /> MySQL thread id 28, OS thread handle 0x130133000, query id 4369 localhost 127.0.0.1 root init  <br /></code></pre><div><br /></div><div><b>Optimising locking by adding an index.</b></div><div>If we give the table a index on the column&nbsp;the database will be able to optimise its locking to just the rows that it knows match the query.</div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> create index IX_TabFoo_bla on TabFoo(blah);  <br /> update TabFoo set bla = ‘bla’ where foo = ‘bla';  <br /> ---TRANSACTION 4830039, ACTIVE 3 sec  <br /> 4 lock struct(s), heap size 1184, 5 row lock(s), undo log entries 2  <br /> MySQL thread id 28, OS thread handle 0x130133000, query id 4411 localhost 127.0.0.1 root init  </code></pre><div>As you can see its locking 5 rows, not all of them. I actually only have 2 rows that match the query so its strange that its locking more than that, there may be some internal database reason, maybe its locked the table page&nbsp;or something, but its a lot better.</div><div><br /></div>As you can see MySQL provides good tools to understand its performance characteristics, you can use these to optimise your database and application to be faster and more reliable. If you ever run into deadlock issues you can try to minimise locking to avoid them.