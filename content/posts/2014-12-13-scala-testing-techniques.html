---
layout: post
title: Scala Testing Techniques
date: '2014-12-13T18:03:00.001-08:00'
author: Stephen Nancekivell
tags: 
modified_time: '2014-12-29T02:18:56.413-08:00'
blogger_id: tag:blogger.com,1999:blog-2519344180739427574.post-8631018348467475457
blogger_orig_url: http://blog.stephenn.com/2014/12/scala-testing-techniques.html
---

<div>This post is about some of the different ways we can test our scala code. I think this is a bit of an overlooked subject, you don’t see too many scala tutorials that show you how you should test and its often quite different. At the surface this seems pretty basic, but like most code there are lots of ways to do it.</div><div><br /></div><div><b>No mocking</b><br /><b><br /></b></div><div>You could test something by running it, and checking that it does what it should. This is the basic plan of testing. When it gets a bit more complicated you may want some strategies to help with this. To deal with breaking up and testing separate parts etc.</div><div><div><br /></div><div>For example if you want to test saving something. Say you have your userRepositiory.</div><div><br /></div><div>You can simply have a test like.</div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> import org.specs2.mutable.Specification  <br /> import play.api.test.Helpers._  <br /> import play.api.test._  <br /> import play.api.Play.current  <br /> import play.api.db.DB  <br /> import anorm._  <br /> class UserSpec extends Specification {  <br />  “User model" should {  <br />   "find all Users" in new WithApplication {  <br />      DB.withConnection { implicit connection =&gt;  <br />         SQL(“insert into Users (‘uname’)).execute()  <br />         val found = User.find()  <br />         found must equalTo Seq(User(“uname"))  <br />      }  <br />   }  <br />  }  <br /> }  <br /></code></pre><div><br /></div></div><div><br /></div><div>This works fine and play framework gives you nice tools to be able to do this easily. I’d do this while its simple, but once you start getting many dependencies it can get messy.</div><div><br /></div><b>mocking</b> <br /><div>Everyone is probably familiar with mockito, the java library for testing that uses reflection to define anonymous classes, and define what method calls should return.</div><div><br /></div><div>You typically want to use this to stop the real action happening.</div><div><br /></div><div>Consider the simple example you may want to test. Saving an entity to a database. You may want to avoid the actual saving, and check that your code still passes whatever data through.</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> val mockRepo = mock[UserRepository]  <br /> when(mockRepo.save(any[user])) thenReturn True  <br /> ..  <br /> there was one(mockRepo.save(any[user]))  <br /></code></pre><br /><div>These work well for testing your logic around the mocked component. You should be sure that you have tested the mocked component too. You need to be careful it is possible that bugs can slip through here, for example if your data is going to break a constraint in the database.</div><div><br /></div><div><br /></div><div><div><b>trait overloading</b><br /><b><br /></b></div></div><div>You can define your code in a trait and use overloading to change it in test. e.g.</div><div><br /></div><div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> trait TheAPI {  <br />    def getMe: Future[User] = {  <br />      WS.get("www.api.3rdparty.com/users”).map { res =&gt;  <br />         Json.reads[User](res.json)  <br />      }  <br />    }  <br /> }  <br /> val mockedAPI = new TheAPI {  <br />    overload getMe: Future[User] = Future(User(“me!!”))  <br /> }  <br /></code></pre></div><div><br /></div><div>When you do this, you need to do a bit more to compose your code so you can use it, similar to cake pattern.</div><div><br /></div><div><b>cake pattern</b></div><div>There are more detailed explanations of cake pattern out there you can read, but the gist of it is to use traits cleverly for dependency injection.&nbsp;It can be used to inject different implementations for test.</div><div><div><br /></div><div>Say you have a object like this.</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> trait MegaController with UserRepo  <br /> val prodMegaController = MegaController with DatabaseUserRepo  <br /> val testMegaController = MegaController with TestUserRepo   <br /> trait UserRepo {  <br />    def find: Option[User]  <br />    def save(u: User): Unit  <br /> }  <br /></code></pre></div><div><br /></div><div>This is great because its just using a language feature, everything is type safe and static. As opposed to mockito where it makes objects for everything.</div><div><br /></div><div><br /></div><div><b>Play framework plugins</b></div><div>Another option, if you are using the play framework is to put the dependencies into plugins and inject test plugins into unit tests.</div><div><div><br /></div></div><div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> class SomeApi(app: Application) extends Plugin {  <br />    def doIt: String = ???  <br /> }  <br /> class TestAPI(app: Application) extends SomeApi(app) {  <br />    override def doIt = “test"  <br /> }  <br /> object SomeController extends Controller {  <br />    val someApi = Play.application.plugin[SomeApi]  <br />      .getOrElse(throw new RuntimeException(“SomeApi not loaded”))  <br />    def doIt = ???  <br /> }  <br /> “the API user” should {  <br />    val fakeApp = FakeApplication(  <br />      withoutPlugins = Seq(“SomeApi”),  <br />      additionalPlugins = Seq(“TestApi")  <br />    )  <br />    “do something with it” in running(fakeApp){  <br />      SomeController.doIt  <br />    }  <br /> }  <br /></code></pre><div><br /></div></div><div><br /></div><div><div><b>functional separation.</b></div></div><div><b><br /></b></div><div>My examples so far have been pretty simple. </div><div>You all know how code gets complicated anyway, and see whats going to happen, but lets consider a this example that makes suddenly some of these techniques have a lot of merrit.</div><div><br /></div><div>Consider the following example which is slightly more complicated, it has nested uses of third party API’s, with some logic.</div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> object CrazyJob {  <br />    def doit: Unit {  <br />      val a = WS.get('api.3rdparty.com/crazyUrl')  <br />      a.map { data1 =&gt;  <br />         val sensibleData = MakeSenseOf(data1)  <br />         val data2 = if (isEligable(sensibleData)) {  <br />           OurSecretSource.addSpice(sensibleData)  <br />         } else sensibleData  <br />         WS.post('api.3rdparty.com/whackyUrl', data2).map { resp =&gt;  <br />           if (resp.status != 200){  <br />              log.error("it didnt work :("+resp)  <br />           }  <br />         }  <br />      }  <br />    }  <br /> }  <br /></code></pre><div><br /></div><div>To test that as it is you’d need to mock both 3rd parties, which is fine and can be done easily. However it might be easier to split the code up and test the pieces independently, or even only test some of it. Its good to be able to test the detail at the level, rather than having lots of big integration tests exercising all of the logic.</div><div><div><br /></div><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> object CarzyJob {  <br />    def doit: Unit {  <br />      val in = getData()  <br />      val transformed = transform(in)  <br />      val send(transformed)  <br />    }  <br />    def getData = {  <br />      val a = WS.get('api.3rdparty.com/crazyUrl')  <br />    }  <br />    def send(data: A) = {  <br />      WS.post('api.3rdparty.com/whackyUrl', data2).map { resp =&gt;  <br />         if (resp.status != 200){  <br />           log.error("it didnt work :("+resp)  <br />         }  <br />      }  <br />    }  <br />    def transform(in: Seq[A]) = {  <br />      if (isEligable(in)) {  <br />         OurSecretSource.addSpice(in)  <br />      } else in  <br />    }  <br /> }  <br /></code></pre></div><div><br /></div><div><br /><b>Futures</b><br />When your working with futures be careful to wait for them in your tests. Even if your using Future.successful in a mock and your just testing a side effect. Not waiting can lead to random test failures.<br /><pre style="background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> val future = testCtrl.makeUser(User("Bill"))  <br /> future.map { res =&gt;  <br />  res.isSuccess  <br /> }.await  <br /></code></pre><br /></div><div><b>Conclusion</b></div><br /><div>There are many ways to test code, be familiar with them, use them in the right context and enjoy writing tested maintainable code.</div>